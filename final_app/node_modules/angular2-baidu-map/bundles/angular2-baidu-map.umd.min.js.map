{"version":3,"sources":["ng://angular2-baidu-map/helpers/object.ts","ng://angular2-baidu-map/helpers/transformer.ts","ng://angular2-baidu-map/helpers/validate.ts","ng://angular2-baidu-map/providers/scriptLoader.ts","ng://angular2-baidu-map/types/Map.ts","ng://angular2-baidu-map/providers/mapService.ts","ng://angular2-baidu-map/components/control.component.ts","ng://angular2-baidu-map/components/map.component.ts","ng://angular2-baidu-map/components/marker.component.ts","ng://angular2-baidu-map/components/polyline.component.ts","ng://angular2-baidu-map/components/circle.component.ts","ng://angular2-baidu-map/components/polygon.component.ts","ng://angular2-baidu-map/components/heatmap.component.ts","ng://angular2-baidu-map/components/tilelayer.component.ts","ng://angular2-baidu-map/components/trafficlayer.component.ts","ng://angular2-baidu-map/components/canvaslayer.component.ts","ng://angular2-baidu-map/components/markerClusterer.component.ts","ng://angular2-baidu-map/index.ts","ng://angular2-baidu-map/types/Control.ts"],"names":["isNull","obj","undefined","isUndefined","isBoolean","Object","prototype","toString","call","isString","toPoint","opts","window","BMap","Point","lng","lat","toPoints","map","p","toSize","Size","width","height","toIcon","url","size","options","Icon","iconOptions","anchor","imageOffset","infoWindowAnchor","printImageUrl","icon","imageSize","setImageSize","toMarkerOptions","offset","imageUrl","enableMassClear","enableDragging","enableClicking","raiseOnDrag","draggingCursor","rotation","title","shadow","toTextIconStyle","style","realStyle","textSize","textColor","nullCheck","msg","Error","ScriptLoaderConfig","_scriptLoadState","_loadingCallbacks","ScriptLoader","load","isMain","cb","scriptKey","scriptUrls","LOADING_STATE","LOADED","switchDisplay","LOADING","push","baidumapinit","forEach","c","appendScriptsTag","urls","leftObj","count","length","appendScriptTag","script","document","createElement","type","src","onerror","body","removeChild","setTimeout","onload","appendChild","Injectable","selector","state","Array","slice","querySelectorAll","node","display","isMapTypeEnum","maptype","isFunction","getTileLayer","MapService","config","_loader","_this","this","ak","_config","_map","Promise","resolve","_mapResolver","createMap","el","mapOptions","URL","Map","omit","keys","_i","arguments","filter","k","indexOf","reduce","v","setOptions","disableDragging","enableScrollWheelZoom","disableDoubleClickZoom","enableKeyboard","enableInertialDragging","enableAutoResize","enableContinuousZoom","disablePinchToZoom","then","cursor","setDefaultCursor","setDraggingCursor","currentCity","setCurrentCity","centerAndZoom","zoom","mapType","realType","setMapType","addOverlay","overlay","removeOverlay","addTileLayer","tilelayer","removeTileLayer","addControl","control","removeControl","getNativeMap","decorators","Inject","args","ControlComponent","_service","EventEmitter","ngOnInit","createControl","_a","loaded","emit","ngOnDestroy","NavigationControl","toNavigationControlOptions","enableGeolocation","showZoomInfo","OverviewMapControl","toOverviewMapControlOptions","isOpen","ScaleControl","toScaleControlOptions","MapTypeControl","toMapTypeControlOptions","GeolocationControl","toGeolocationOptions","enableAutoLocation","locationIcon","showAddressBar","PanoramaControl","Directive","Input","Output","MapComponent","mapInstance","nativeElement","addListener","ngOnChanges","changes","console","warn","log","addEventListener","e","clicked","Component","providers","styles","template","ViewChild","MarkerComponent","point","marker","Marker","setPosition","isFirstChange","currentValue","setOffset","setIcon","setRotation","setShadow","setTitle","PolylineComponent","points","polyline","Polyline","setPath","enableEditing","disableEditing","disableMassClear","strokeColor","setStrokeColor","strokeOpacity","setStrokeOpacity","strokeStyle","setStrokeStyle","strokeWeight","setStrokeWeight","CircleComponent","center","radius","circle","Circle","setCenter","setRadius","fillColor","setFillColor","fillOpacity","setFillOpacity","PolygonComponent","polygon","Polygon","HeatmapComponent","scriptLoader","dataset","heatmap","BMapLib","HeatmapOverlay","setDataSet","TileLayerComponent","func","getTilesUrl","TileLayer","tileCoord","TrafficLayerComponent","trafficlayer","TrafficLayer","CanvasLayerComponent","canvaslayer","CanvasLayer","getOptions","isNumber","zIndex","paneName","update","canvas","LIB_URLS","key","scripts","MarkerClustererComponent","markerClusterer","MarkerClusterer","toMarkerClustererOptions","markers","m","girdSize","maxZoom","minClusterSize","isAverangeCenter","s","resetOptions","clearMarkers","addMarkers","setGridSize","setMaxZoom","setStyles","BaiduMapModule","forRoot","ngModule","provide","useValue","NgModule","declarations","exports"],"mappings":"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","sourcesContent":["export function isNull(obj: any) {\n  return obj === null || obj === undefined\n}\n\nexport function isUndefined(obj: any) {\n  return obj === undefined\n}\n\nexport function isBoolean(obj: any): obj is boolean {\n  return Object.prototype.toString.call(obj) === '[object Boolean]'\n}\n\nexport function isFunction(obj: any): obj is boolean {\n  return Object.prototype.toString.call(obj) === '[object Function]'\n}\n\nexport function isString(obj: any): obj is boolean {\n  return Object.prototype.toString.call(obj) === '[object String]'\n}\n\nexport function isNumber(obj: any): obj is boolean {\n  return Object.prototype.toString.call(obj) === '[object Number]'\n}\n\nexport function omit<T>(obj: T, ...keys: Array<string>): T {\n  const rawKeys = Object.keys(obj)\n  const finalKeys = rawKeys.filter(k => keys.indexOf(k) < 0)\n  return finalKeys.reduce(\n    (p, v) => {\n      p[v] = obj[v]\n      return p\n    },\n    <T>{}\n  )\n}\n","import {\n  BGeolocationControlOptions,\n  BMapTypeControlOptions,\n  BNavigationControlOptions,\n  BOverviewMapControlOptions,\n  BScaleControlOptions,\n  GeolocationControlOptions,\n  MapTypeControlOptions,\n  NavigationControlOptions,\n  OverviewMapControlOptions,\n  ScaleControlOptions\n} from '../types/Control'\nimport { BIcon, IconOptions } from '../types/Icon'\nimport { BMarkerOptions, MarkerOptions } from '../types/Marker'\nimport { BPoint, Point } from '../types/Point'\nimport { BSize, Size } from '../types/Size'\n\nimport { isNull } from './object'\nimport { BMarkerClustererOptions, MarkerClustererOptions } from '../types/MarkerClusterer'\nimport { TextIconStyle, BTextIconStyle } from '../types/TextIconOverlay'\n\nexport function toPoint(opts: Point): BPoint {\n  if (!opts) {\n    return new window.BMap.Point()\n  }\n  return new window.BMap.Point(opts.lng, opts.lat)\n}\n\nexport function toPoints(opts: Array<Point>): Array<BPoint> {\n  if (!opts) {\n    return []\n  }\n  return opts.map(p => {\n    return new window.BMap.Point(p.lng, p.lat)\n  })\n}\n\nexport function toSize(opts: Size): BSize {\n  if (!opts) {\n    return new window.BMap.Size()\n  }\n  return new window.BMap.Size(opts.width, opts.height)\n}\n\nexport function toIcon(url: string, size: Size, options: IconOptions): BIcon {\n  if (!size && !options) {\n    return new window.BMap.Icon(url)\n  }\n  if (!size) {\n    return new window.BMap.Icon(url, toSize(size))\n  }\n  const iconOptions: any = {\n    anchor: toSize(options.anchor),\n    imageOffset: toSize(options.imageOffset),\n    infoWindowAnchor: toSize(options.infoWindowAnchor),\n    printImageUrl: options.printImageUrl\n  }\n  const icon = new window.BMap.Icon(url, toSize(size), iconOptions)\n  if (options.imageSize) {\n    icon.setImageSize(toSize(options.imageSize))\n  }\n  return icon\n}\n\nexport function toMarkerOptions(options: MarkerOptions): BMarkerOptions {\n  const opts: BMarkerOptions = {}\n\n  if (!options) {\n    return opts\n  }\n\n  if (options.offset) {\n    opts.offset = toSize(options.offset)\n  }\n\n  if (options.icon) {\n    opts.icon = toIcon(options.icon.imageUrl, options.icon.size, options.icon)\n  }\n  if (!isNull(options.enableMassClear)) {\n    opts.enableMassClear = options.enableMassClear\n  }\n  if (!isNull(options.enableDragging)) {\n    opts.enableDragging = options.enableDragging\n  }\n  if (!isNull(options.enableClicking)) {\n    opts.enableClicking = options.enableClicking\n  }\n  if (!isNull(options.raiseOnDrag)) {\n    opts.raiseOnDrag = options.raiseOnDrag\n  }\n  if (!isNull(options.draggingCursor)) {\n    opts.draggingCursor = options.draggingCursor\n  }\n  if (!isNull(options.rotation)) {\n    opts.rotation = options.rotation\n  }\n  if (!isNull(options.title)) {\n    opts.title = options.title\n  }\n  if (!isNull(options.shadow)) {\n    opts.shadow = toIcon(options.shadow.imageUrl, options.shadow.size, options.shadow)\n  }\n\n  return opts\n}\n\nexport function toNavigationControlOptions(options: NavigationControlOptions): BNavigationControlOptions {\n  const opts: BNavigationControlOptions = {}\n\n  if (!options) {\n    return opts\n  }\n\n  if (!isNull(options.anchor)) {\n    opts.anchor = options.anchor\n  }\n  if (!isNull(options.enableGeolocation)) {\n    opts.enableGeolocation = options.enableGeolocation\n  }\n  if (!isNull(options.offset)) {\n    opts.offset = toSize(options.offset)\n  }\n  if (!isNull(options.showZoomInfo)) {\n    opts.showZoomInfo = options.showZoomInfo\n  }\n\n  if (!isNull(options.type)) {\n    opts.type = options.type\n  }\n  return opts\n}\n\nexport function toOverviewMapControlOptions(options: OverviewMapControlOptions): BOverviewMapControlOptions {\n  const opts: BOverviewMapControlOptions = {}\n\n  if (!options) {\n    return opts\n  }\n\n  if (!isNull(options.anchor)) {\n    opts.anchor = options.anchor\n  }\n  if (!isNull(options.isOpen)) {\n    opts.isOpen = options.isOpen\n  }\n  if (!isNull(options.offset)) {\n    opts.offset = toSize(options.offset)\n  }\n  if (!isNull(options.size)) {\n    opts.size = toSize(options.size)\n  }\n  return opts\n}\n\nexport function toScaleControlOptions(options: ScaleControlOptions): BScaleControlOptions {\n  const opts: BScaleControlOptions = {}\n\n  if (!options) {\n    return opts\n  }\n\n  if (!isNull(options.anchor)) {\n    opts.anchor = options.anchor\n  }\n  if (!isNull(options.offset)) {\n    opts.offset = toSize(options.offset)\n  }\n  return opts\n}\n\nexport function toMapTypeControlOptions(options: MapTypeControlOptions): BMapTypeControlOptions {\n  const opts: BMapTypeControlOptions = {}\n\n  if (!options) {\n    return opts\n  }\n\n  if (!isNull(options.type)) {\n    opts.type = options.type\n  }\n  return opts\n}\nexport function toGeolocationOptions(options: GeolocationControlOptions): BGeolocationControlOptions {\n  const opts: BGeolocationControlOptions = {}\n\n  if (!options) {\n    return opts\n  }\n\n  if (!isNull(options.anchor)) {\n    opts.anchor = options.anchor\n  }\n  if (!isNull(options.offset)) {\n    opts.offset = toSize(options.offset)\n  }\n  if (!isNull(options.enableAutoLocation)) {\n    opts.enableAutoLocation = options.enableAutoLocation\n  }\n  if (!isNull(options.locationIcon)) {\n    opts.locationIcon = toIcon(options.locationIcon.imageUrl, options.locationIcon.size, options.locationIcon)\n  }\n  if (!isNull(options.showAddressBar)) {\n    opts.showAddressBar = options.showAddressBar\n  }\n  return opts\n}\n\nexport function toTextIconStyle(style: TextIconStyle): BTextIconStyle {\n  const realStyle: BTextIconStyle = {\n    url: style.url,\n    size: toSize(style.size)\n  }\n  if (style.anchor) {\n    realStyle.anchor = toSize(style.anchor)\n  }\n  if (style.offset) {\n    realStyle.offset = toSize(style.offset)\n  }\n  if (!isNull(style.textSize)) {\n    realStyle.textSize = style.textSize\n  }\n  if (!isNull(style.textColor)) {\n    realStyle.textColor = style.textColor\n  }\n\n  return realStyle\n}\n\nexport function toMarkerClustererOptions(options: MarkerClustererOptions): BMarkerClustererOptions {\n  const opts: BMarkerClustererOptions = {}\n\n  if (!options) {\n    return opts\n  }\n\n  if (options.markers) {\n    opts.markers = options.markers.map(\n      m => new window.BMap.Marker(toPoint(m.point), toMarkerOptions(m.options))\n    )\n  }\n\n  if (!isNull(options.girdSize)) {\n    opts.girdSize = options.girdSize\n  }\n  if (!isNull(options.maxZoom)) {\n    opts.maxZoom = options.maxZoom\n  }\n  if (!isNull(options.minClusterSize)) {\n    opts.minClusterSize = options.minClusterSize\n  }\n  if (!isNull(options.isAverangeCenter)) {\n    opts.isAverangeCenter = options.isAverangeCenter\n  }\n  if (options.styles) {\n    opts.styles = options.styles.filter(s => s).map(s => toTextIconStyle(s))\n  }\n\n  return opts\n}\n","import { isNull } from './object'\n\nexport function nullCheck(obj: any, msg: string) {\n  if (isNull(obj)) {\n    throw new Error(msg)\n  }\n}\n","import { Injectable } from '@angular/core'\nimport { isString } from '../helpers/object'\nimport { ScriptType } from '../types/Script'\n\nexport enum LOADING_STATE {\n  NON = 0,\n  LOADED = 1,\n  LOADING = 2\n}\n\nexport class ScriptLoaderConfig {\n  public ak: string = ''\n}\n\nwindow._scriptLoadState = {}\nwindow._loadingCallbacks = {}\n\n@Injectable()\nexport class ScriptLoader {\n  public load(url: string | ScriptType, isMain: boolean = false, cb: () => void): void {\n    const scriptKey = isString(url) ? url : url['key']\n    const scriptUrls = isString(url) ? [url] : url['scripts']\n\n    if (window._scriptLoadState[scriptKey] === LOADING_STATE.LOADED) {\n      if (isMain) {\n        switchDisplay('baidu-map .baidu-map-instance', 'block')\n        switchDisplay('baidu-map .baidu-map-offline', 'none')\n      }\n      return cb()\n    }\n    if (!window._loadingCallbacks[scriptKey]) {\n      window._loadingCallbacks[scriptKey] = []\n    }\n    if (window._scriptLoadState[scriptKey] === LOADING_STATE.LOADING) {\n      window._loadingCallbacks[scriptKey].push(cb)\n      return\n    }\n    window._scriptLoadState[scriptKey] = LOADING_STATE.LOADING\n    window._loadingCallbacks[scriptKey].push(cb)\n\n    if (isMain) {\n      window.baidumapinit = () => {\n        window._scriptLoadState[scriptKey] = LOADING_STATE.LOADED\n        switchDisplay('baidu-map .baidu-map-instance', 'block')\n        switchDisplay('baidu-map .baidu-map-offline', 'none')\n        window._loadingCallbacks[scriptKey].forEach((c: () => void) => {\n          c()\n        })\n      }\n    }\n    appendScriptsTag(scriptKey, scriptUrls, isMain)\n  }\n}\n\nfunction appendScriptsTag(scriptKey: string, urls: Array<string>, isMain: boolean) {\n  const leftObj = {\n    count: urls.length\n  }\n  urls.forEach(url => {\n    appendScriptTag(scriptKey, url, isMain, leftObj)\n  })\n}\n\nfunction appendScriptTag(scriptKey: string, url: string, isMain: boolean, leftObj: { count: number }) {\n  const script = document.createElement('script')\n  script.type = 'text/javascript'\n  script.src = url\n  script.onerror = () => {\n    if (isMain) {\n      switchDisplay('baidu-map .baidu-map-offline', 'block')\n      switchDisplay('baidu-map .baidu-map-instance', 'none')\n    }\n    document.body.removeChild(script)\n\n    setTimeout(() => {\n      appendScriptTag(scriptKey, url, isMain, leftObj)\n    }, 30000)\n  }\n\n  if (!isMain) {\n    script.onload = () => {\n      leftObj.count--\n      if (leftObj.count) {\n        return\n      }\n      window._scriptLoadState[scriptKey] = LOADING_STATE.LOADED\n      window._loadingCallbacks[scriptKey].forEach((c: () => void) => {\n        c()\n      })\n    }\n  }\n  document.body.appendChild(script)\n}\n\nfunction switchDisplay(selector: string, state: string) {\n  Array.prototype.slice.call(document.querySelectorAll(selector)).forEach((node: HTMLElement) => {\n    node.style.display = state\n  })\n}\n","import { BBounds } from './Bounds'\nimport { BControl } from './Control'\nimport { Overlay } from './Overlay'\nimport { BPoint, Point } from './Point'\nimport { BTileLayer } from './TileLayer'\nimport { isFunction } from '../helpers/object'\nimport { BSize } from './Size'\nimport { BInfoWindow } from './InfoWindow'\nimport { BMapType } from './MapType'\nimport { BPixel } from './Pixel'\n\nexport interface BMapConstructor {\n  new (el: HTMLElement | string, opts: MapOptions): BMapInstance\n}\n\nexport interface BMapInstance {\n  disableDragging(): void\n  enableDragging(): void\n\n  disableScrollWheelZoom(): void\n  enableScrollWheelZoom(): void\n\n  disableDoubleClickZoom(): void\n  enableDoubleClickZoom(): void\n\n  disableKeyboard(): void\n  enableKeyboard(): void\n\n  disableInertialDragging(): void\n  enableInertialDragging(): void\n\n  disableContinuousZoom(): void\n  enableContinuousZoom(): void\n\n  disablePinchToZoom(): void\n  enablePinchToZoom(): void\n\n  disableAutoResize(): void\n  enableAutoResize(): void\n\n  addControl(control: BControl): void\n  removeControl(control: BControl): void\n\n  addOverlay(control: Overlay): void\n  removeOverlay(control: Overlay): void\n  clearOverlays(): void\n\n  addTileLayer(tileLayer: BTileLayer): void\n  removeTileLayer(tileLayer: BTileLayer): void\n\n  setDefaultCursor(cursor: string): void\n  getDefaultCursor(): string\n\n  setDraggingCursor(draggingCursor: string): void\n  getDraggingCursor(): string\n\n  setMinZoom(zoom: number): void\n  setMaxZoom(zoom: number): void\n\n  getBounds(): BBounds\n\n  setCenter(center: BPoint | string): void\n  getCenter(): BPoint\n\n  getDistance(start: BPoint, end: BPoint): number\n\n  setCurrentCity(city: string): void\n  centerAndZoom(center: BPoint, zoom: number): void\n\n  setMapType(mapType: BMapType | MapTypeEnum): void\n  getMapType(): BMapType\n\n  getSize(): BSize\n\n  setZoom(zoom: number): void\n  getZoom(): number\n\n  panTo(center: BPoint, opts: BPanOptions): void\n\n  panBy(x: number, y: number, opts: BPanOptions): void\n\n  reset(): void\n\n  highResolutionEnabled(): boolean\n\n  zoomIn(): void\n  zoomOut(): void\n\n  getContainer(): HTMLElement\n\n  closeInfoWindow(): void\n\n  pixelToPoint(pixel: BPixel): BPoint\n\n  pointToPixel(point: BPoint): BPixel\n\n  openInfoWindow(infoWnd: BInfoWindow, point: BPoint): void\n\n  addEventListener(event: string, handler: (e: any) => void): void\n  removeEventListener(event: string, handler: () => void): void\n}\n\nexport interface MapOptions {\n  minZoom?: number\n  maxZoom?: number\n  enableHighResolution?: boolean\n  enableAutoResize?: boolean\n  enableMapClick?: boolean\n\n  disableDragging?: boolean\n  enableScrollWheelZoom?: boolean\n  disableDoubleClickZoom?: boolean\n  enableKeyboard?: boolean\n  enableInertialDragging?: boolean\n  enableContinuousZoom?: boolean\n  disablePinchToZoom?: boolean\n\n  cursor?: string\n  draggingCursor?: string\n  currentCity?: string\n  centerAndZoom?: CenterAndZoom\n\n  mapType?: BMapType | MapTypeEnum\n}\n\nexport interface CenterAndZoom extends Point {\n  zoom?: number\n}\n\nexport interface BPanOptions {\n  noAnimation: boolean\n}\n\nexport enum MapTypeEnum {\n  BMAP_NORMAL_MAP = 'BMAP_NORMAL_MAP',\n  BMAP_PERSPECTIVE_MAP = 'BMAP_PERSPECTIVE_MAP',\n  BMAP_SATELLITE_MAP = 'BMAP_SATELLITE_MAP',\n  BMAP_HYBRID_MAP = 'BMAP_HYBRID_MAP'\n}\n\nexport function isMapTypeEnum(maptype: MapTypeEnum | BMapType): maptype is MapTypeEnum {\n  return !isFunction((<BMapType>maptype).getTileLayer)\n}\n","import { Injectable, Inject } from '@angular/core'\nimport { isBoolean, isNull, omit } from '../helpers/object'\nimport { nullCheck } from '../helpers/validate'\nimport { BControl } from '../types/Control'\nimport { ScriptLoaderConfig } from './scriptLoader'\nimport { BMapInstance, MapOptions, isMapTypeEnum } from '../types/Map'\nimport { Overlay } from '../types/Overlay'\nimport { BTileLayer } from '../types/TileLayer'\n\nimport { toPoint } from '../helpers/transformer'\n\nimport { ScriptLoader } from './scriptLoader'\n\n@Injectable()\nexport class MapService {\n  private _config: ScriptLoaderConfig\n\n  private _map: Promise<BMapInstance>\n  private _mapResolver: (value: BMapInstance) => void\n\n  constructor(@Inject(ScriptLoaderConfig) config: ScriptLoaderConfig, private _loader: ScriptLoader) {\n    nullCheck(config.ak, 'ak must be provided')\n\n    this._config = config\n\n    this._map = new Promise<BMapInstance>((resolve: () => void) => {\n      this._mapResolver = resolve\n    })\n  }\n\n  public createMap(el: HTMLElement, mapOptions: MapOptions): Promise<BMapInstance> {\n    const URL = `https://api.map.baidu.com/api?v=3.0&ak=${this._config.ak}&callback=baidumapinit`\n\n    return new Promise(resolve => {\n      this._loader.load(URL, true, () => {\n        const map = new window.BMap.Map(el, omit(mapOptions, 'mapType'))\n        this.setOptions(mapOptions)\n        this._mapResolver(map)\n        resolve(map)\n      })\n    })\n  }\n\n  public setOptions(opts: MapOptions): void {\n    const {\n      disableDragging,\n      enableScrollWheelZoom,\n      disableDoubleClickZoom,\n      enableKeyboard,\n      enableInertialDragging,\n      enableAutoResize,\n      enableContinuousZoom,\n      disablePinchToZoom\n    } = opts\n\n    if (isBoolean(disableDragging)) {\n      this._map.then(map => map[(disableDragging ? 'disable' : 'enable') + 'Dragging']())\n    }\n    if (isBoolean(enableScrollWheelZoom)) {\n      this._map.then(map => map[(enableScrollWheelZoom ? 'enable' : 'disable') + 'ScrollWheelZoom']())\n    }\n    if (isBoolean(enableAutoResize)) {\n      this._map.then(map => map[(enableAutoResize ? 'enable' : 'disable') + 'AutoResize']())\n    }\n    if (isBoolean(disableDoubleClickZoom)) {\n      this._map.then(map => map[(disableDoubleClickZoom ? 'disable' : 'enable') + 'DoubleClickZoom']())\n    }\n    if (isBoolean(enableKeyboard)) {\n      this._map.then(map => map[(enableKeyboard ? 'enable' : 'disable') + 'Keyboard']())\n    }\n    if (isBoolean(enableInertialDragging)) {\n      this._map.then(map => map[(enableInertialDragging ? 'enable' : 'disable') + 'InertialDragging']())\n    }\n    if (isBoolean(enableContinuousZoom)) {\n      this._map.then(map => map[(enableContinuousZoom ? 'enable' : 'disable') + 'ContinuousZoom']())\n    }\n    if (isBoolean(disablePinchToZoom)) {\n      this._map.then(map => map[(disablePinchToZoom ? 'disable' : 'enable') + 'PinchToZoom']())\n    }\n    if (!isNull(opts.cursor)) {\n      this._map.then(map => map.setDefaultCursor(opts.cursor))\n    }\n    if (!isNull(opts.draggingCursor)) {\n      this._map.then(map => map.setDraggingCursor(opts.draggingCursor))\n    }\n    if (!isNull(opts.currentCity)) {\n      this._map.then(map => map.setCurrentCity(opts.currentCity))\n    }\n    if (!isNull(opts.centerAndZoom)) {\n      this._map.then(map => {\n        map.centerAndZoom(toPoint(opts.centerAndZoom), opts.centerAndZoom.zoom)\n      })\n    }\n    if (!isNull(opts.mapType)) {\n      this._map.then(map => {\n        const realType = isMapTypeEnum(opts.mapType) ? window[opts.mapType] : opts.mapType\n        map.setMapType(realType)\n      })\n    }\n  }\n\n  public addOverlay(cb: (map: BMapInstance) => Overlay): Promise<{ map: BMapInstance; overlay: Overlay }> {\n    return this._map.then((map: BMapInstance) => {\n      const overlay = cb(map)\n      map.addOverlay(overlay)\n      return { map, overlay }\n    })\n  }\n\n  public removeOverlay(overlay: Overlay): Promise<void> {\n    return this._map.then((map: BMapInstance) => {\n      map.removeOverlay(overlay)\n    })\n  }\n\n  public addTileLayer(\n    cb: (map: BMapInstance) => BTileLayer\n  ): Promise<{ map: BMapInstance; tilelayer: BTileLayer }> {\n    return this._map.then((map: BMapInstance) => {\n      const tilelayer = cb(map)\n      map.addTileLayer(tilelayer)\n      return { map, tilelayer }\n    })\n  }\n\n  public removeTileLayer(tilelayer: BTileLayer): Promise<void> {\n    return this._map.then((map: BMapInstance) => {\n      map.removeOverlay(tilelayer)\n    })\n  }\n\n  public addControl(cb: (map: BMapInstance) => BControl): Promise<{ map: BMapInstance; control: BControl }> {\n    return this._map.then((map: BMapInstance) => {\n      const control = cb(map)\n      map.addControl(control)\n      return { map, control }\n    })\n  }\n\n  public removeControl(control: BControl): Promise<void> {\n    return this._map.then((map: BMapInstance) => {\n      map.removeControl(control)\n    })\n  }\n\n  public getNativeMap(): Promise<BMapInstance> {\n    return this._map\n  }\n}\n","import { Directive, EventEmitter, Input, Output, OnDestroy, OnInit } from '@angular/core'\n\nimport {\n  toGeolocationOptions,\n  toMapTypeControlOptions,\n  toNavigationControlOptions,\n  toOverviewMapControlOptions,\n  toScaleControlOptions\n} from '../helpers/transformer'\nimport { nullCheck } from '../helpers/validate'\nimport { MapService } from '../providers/mapService'\nimport { BControl, ControlType } from '../types/Control'\n\n@Directive({\n  selector: 'control'\n})\nexport class ControlComponent implements OnInit, OnDestroy {\n  @Input() private type: ControlType\n  @Input() private options: { [key: string]: any }\n\n  @Output() private loaded = new EventEmitter()\n\n  private control: BControl\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    nullCheck(this.type, 'type is required for <control>')\n\n    this._service\n      .addControl(() => {\n        this.control = this.createControl(this.type, this.options)\n        return this.control\n      })\n      .then(({ control }) => {\n        this.loaded.emit(control)\n      })\n  }\n\n  public ngOnDestroy() {\n    this._service.removeControl(this.control)\n  }\n\n  private createControl(type: ControlType, options: { [key: string]: any }): BControl {\n    if (type === 'navigation') {\n      return new window.BMap.NavigationControl(toNavigationControlOptions(options))\n    }\n    if (type === 'overviewmap') {\n      return new window.BMap.OverviewMapControl(toOverviewMapControlOptions(options))\n    }\n    if (type === 'scale') {\n      return new window.BMap.ScaleControl(toScaleControlOptions(options))\n    }\n    if (type === 'maptype') {\n      return new window.BMap.MapTypeControl(toMapTypeControlOptions(options))\n    }\n    if (type === 'geolocation') {\n      return new window.BMap.GeolocationControl(toGeolocationOptions(options))\n    }\n    if (type === 'panorama') {\n      return new window.BMap.PanoramaControl()\n    }\n    throw new Error(`Unsupported type:${type} of control`)\n  }\n}\n","import {\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnInit,\n  Output,\n  SimpleChange,\n  ViewChild\n} from '@angular/core'\n\nimport { MapService } from '../providers/mapService'\nimport { BMapInstance, MapOptions } from '../types/Map'\n\nimport { nullCheck } from '../helpers/validate'\n\n@Component({\n  providers: [MapService],\n  selector: 'baidu-map',\n  styles: [\n    `\n        .baidu-map-instance {\n            width: 100%;\n            height: 100%;\n            display: none;\n        }\n        .baidu-map-offline {\n            width: 100%;\n            height: 100%;\n            background-color: #E6E6E6;\n            position: relative;\n            display: none;\n        }\n        .baidu-map-offline label {\n            fontSize: 30px;\n            margin: 0;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            margin-right: -50%;\n            transform: translate(-50%, -50%);\n        }\n        .tranclude-content {\n            display: none;\n        }\n        `\n  ],\n  template: `\n    <div #mapinstance class=\"baidu-map-instance\"></div>\n    <div class=\"baidu-map-offline\">\n        <label>{{ 'NO_NETWORK' }}</label>\n    </div>\n    <div class=\"tranclude-content\">\n        <ng-content></ng-content>\n    </div>\n    `\n})\nexport class MapComponent implements OnInit, OnChanges {\n  @Input() private options: MapOptions\n\n  @Output() private loaded = new EventEmitter()\n  @Output() private clicked = new EventEmitter()\n\n  @ViewChild('mapinstance') private mapInstance: ElementRef\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    nullCheck(this.options, 'options is required for <baidu-map>')\n    nullCheck(this.options.centerAndZoom, 'options.centerAndZoom is required for <baidu-map>')\n\n    this._service\n      .createMap(this.mapInstance.nativeElement, this.options)\n      .then(map => {\n        this.loaded.emit(map)\n        return map\n      })\n      .then(map => {\n        this.addListener(map)\n      })\n  }\n\n  public ngOnChanges(changes: { [propertyName: string]: SimpleChange }) {\n    const opts = changes.options.currentValue as MapOptions\n    if (!opts) {\n      return console.warn('MapOptions change was ignored since you are passing empty value')\n    }\n    this._service.setOptions(opts)\n  }\n\n  public ngOnDestroy() {\n    console.log('on map destroy')\n  }\n\n  private addListener(map: BMapInstance) {\n    map.addEventListener('click', (e: any) => {\n      this.clicked.emit(e)\n    })\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChange\n} from '@angular/core'\n\nimport { isNull } from '../helpers/object'\nimport { toIcon, toMarkerOptions, toPoint, toSize } from '../helpers/transformer'\nimport { nullCheck } from '../helpers/validate'\nimport { MapService } from '../providers/mapService'\nimport { BMapInstance } from '../types/Map'\nimport { BMarker, MarkerOptions } from '../types/Marker'\nimport { Point } from '../types/Point'\n\n@Directive({\n  selector: 'marker'\n})\nexport class MarkerComponent implements OnInit, OnChanges, OnDestroy {\n  @Input() private point: Point\n  @Input() private options: MarkerOptions\n\n  @Output() private loaded = new EventEmitter()\n  @Output() private clicked = new EventEmitter()\n\n  private marker: BMarker\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    nullCheck(this.point, 'point is required for <marker>')\n\n    this._service\n      .addOverlay(() => {\n        return (this.marker = new window.BMap.Marker(toPoint(this.point), toMarkerOptions(this.options)))\n      })\n      .then(({ map }) => {\n        this.loaded.emit(this.marker)\n        this.addListener(this.marker, map)\n      })\n      .then(() => {\n        // workaround: it's weird that postion is set while constructing phase will make click event not working\n        this.marker.setPosition(new window.BMap.Point(this.point.lng, this.point.lat))\n      })\n  }\n\n  public ngOnChanges(changes: { [propertyName: string]: SimpleChange }) {\n    if (changes.point && !changes.point.isFirstChange()) {\n      this.marker.setPosition(toPoint(changes.point.currentValue))\n    }\n    if (changes.options && !changes.options.isFirstChange()) {\n      this.setOptions(changes.options.currentValue)\n    }\n  }\n\n  public ngOnDestroy() {\n    this._service.removeOverlay(this.marker)\n  }\n\n  private setOptions(options: MarkerOptions): void {\n    if (isNull(options)) {\n      return\n    }\n    if (!isNull(options.offset)) {\n      this.marker.setOffset(toSize(options.offset))\n    }\n    if (!isNull(options.icon)) {\n      this.marker.setIcon(toIcon(options.icon.imageUrl, options.icon.size, options.icon))\n    }\n    if (!isNull(options.enableMassClear)) {\n      this.marker[(options.enableMassClear ? 'enable' : 'disable') + 'MassClear']()\n    }\n    if (!isNull(options.enableDragging)) {\n      this.marker[(options.enableDragging ? 'enable' : 'disable') + 'Dragging']()\n    }\n    if (!isNull(options.rotation)) {\n      this.marker.setRotation(options.rotation)\n    }\n    if (!isNull(options.shadow)) {\n      this.marker.setShadow(toIcon(options.shadow.imageUrl, options.shadow.size, options.shadow))\n    }\n    if (!isNull(options.title)) {\n      this.marker.setTitle(options.title)\n    }\n  }\n\n  private addListener(marker: BMarker, map: BMapInstance) {\n    marker.addEventListener('click', (e: any) => {\n      this.clicked.emit({\n        e,\n        map,\n        marker\n      })\n    })\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChange\n} from '@angular/core'\n\nimport { isNull, isUndefined } from '../helpers/object'\nimport { toPoints } from '../helpers/transformer'\nimport { nullCheck } from '../helpers/validate'\nimport { MapService } from '../providers/mapService'\nimport { BPolyline, PolylineOptions } from '../types/Polyline'\nimport { Point } from '../types/Point'\n\n@Directive({\n  selector: 'polyline'\n})\nexport class PolylineComponent implements OnInit, OnChanges, OnDestroy {\n  @Input() private points: Array<Point>\n  @Input() private options: PolylineOptions\n\n  @Output() private loaded = new EventEmitter()\n\n  private polyline: BPolyline\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    nullCheck(this.points, 'points is required for <polyline>')\n\n    this._service\n      .addOverlay(() => {\n        return (this.polyline = new window.BMap.Polyline(toPoints(this.points), this.options))\n      })\n      .then(() => {\n        this.loaded.emit(this.polyline)\n      })\n  }\n\n  public ngOnChanges(changes: { [propertyName: string]: SimpleChange }) {\n    if (changes.points && !changes.points.isFirstChange()) {\n      this.polyline.setPath(toPoints(changes.points.currentValue))\n    }\n    if (changes.options && !changes.options.isFirstChange()) {\n      this.setOptions(changes.options.currentValue)\n    }\n  }\n\n  public ngOnDestroy() {\n    this._service.removeOverlay(this.polyline)\n  }\n\n  private setOptions(options: PolylineOptions): void {\n    if (isNull(options)) {\n      return\n    }\n    if (!isUndefined(options.enableEditing)) {\n      if (options.enableEditing) {\n        this.polyline.enableEditing()\n      } else {\n        this.polyline.disableEditing()\n      }\n    }\n    if (!isUndefined(options.enableMassClear)) {\n      if (options.enableEditing) {\n        this.polyline.enableMassClear()\n      } else {\n        this.polyline.disableMassClear()\n      }\n    }\n    if (!isUndefined(options.strokeColor)) {\n      this.polyline.setStrokeColor(options.strokeColor)\n    }\n    if (!isUndefined(options.strokeOpacity)) {\n      this.polyline.setStrokeOpacity(options.strokeOpacity)\n    }\n    if (!isUndefined(options.strokeStyle)) {\n      this.polyline.setStrokeStyle(options.strokeStyle)\n    }\n    if (!isUndefined(options.strokeWeight)) {\n      this.polyline.setStrokeWeight(options.strokeWeight)\n    }\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChange\n} from '@angular/core'\n\nimport { isNull, isUndefined } from '../helpers/object'\nimport { toPoint } from '../helpers/transformer'\nimport { nullCheck } from '../helpers/validate'\nimport { MapService } from '../providers/mapService'\nimport { BCircle, CircleOptions } from '../types/Circle'\nimport { Point } from '../types/Point'\n\n@Directive({\n  selector: 'circle'\n})\nexport class CircleComponent implements OnInit, OnChanges, OnDestroy {\n  @Input() private center: Point\n  @Input() private radius: number\n  @Input() private options: CircleOptions\n\n  @Output() private loaded = new EventEmitter()\n\n  private circle: BCircle\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    nullCheck(this.center, 'center is required for <circle>')\n    nullCheck(this.radius, 'center is required for <circle>')\n\n    this._service\n      .addOverlay(() => {\n        return (this.circle = new window.BMap.Circle(toPoint(this.center), this.radius, this.options))\n      })\n      .then(() => {\n        this.loaded.emit(this.circle)\n      })\n  }\n\n  public ngOnChanges(changes: { [propertyName: string]: SimpleChange }) {\n    if (changes.center && !changes.center.isFirstChange()) {\n      this.circle.setCenter(toPoint(changes.center.currentValue))\n    }\n    if (changes.radius && !changes.radius.isFirstChange()) {\n      this.circle.setRadius(changes.radius.currentValue)\n    }\n    if (changes.options && !changes.options.isFirstChange()) {\n      this.setOptions(changes.options.currentValue)\n    }\n  }\n\n  public ngOnDestroy() {\n    this._service.removeOverlay(this.circle)\n  }\n\n  private setOptions(options: CircleOptions): void {\n    if (isNull(options)) {\n      return\n    }\n    if (!isUndefined(options.enableEditing)) {\n      if (options.enableEditing) {\n        this.circle.enableEditing()\n      } else {\n        this.circle.disableEditing()\n      }\n    }\n    if (!isUndefined(options.enableMassClear)) {\n      if (options.enableEditing) {\n        this.circle.enableMassClear()\n      } else {\n        this.circle.disableMassClear()\n      }\n    }\n    if (!isUndefined(options.strokeColor)) {\n      this.circle.setStrokeColor(options.strokeColor)\n    }\n    if (!isUndefined(options.fillColor)) {\n      this.circle.setFillColor(options.fillColor)\n    }\n    if (!isUndefined(options.strokeOpacity)) {\n      this.circle.setStrokeOpacity(options.strokeOpacity)\n    }\n    if (!isUndefined(options.fillOpacity)) {\n      this.circle.setFillOpacity(options.fillOpacity)\n    }\n    if (!isUndefined(options.strokeStyle)) {\n      this.circle.setStrokeStyle(options.strokeStyle)\n    }\n    if (!isUndefined(options.strokeWeight)) {\n      this.circle.setStrokeWeight(options.strokeWeight)\n    }\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChange\n} from '@angular/core'\n\nimport { isNull, isUndefined } from '../helpers/object'\nimport { toPoints } from '../helpers/transformer'\nimport { nullCheck } from '../helpers/validate'\nimport { MapService } from '../providers/mapService'\nimport { BPolygon, PolygonOptions } from '../types/Polygon'\nimport { Point } from '../types/Point'\n\n@Directive({\n  selector: 'polygon'\n})\nexport class PolygonComponent implements OnInit, OnChanges, OnDestroy {\n  @Input() private points: Array<Point>\n  @Input() private options: PolygonOptions\n\n  @Output() private loaded = new EventEmitter()\n\n  private polygon: BPolygon\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    nullCheck(this.points, 'points is required for <polygon>')\n\n    this._service\n      .addOverlay(() => {\n        return (this.polygon = new window.BMap.Polygon(toPoints(this.points), this.options))\n      })\n      .then(() => {\n        this.loaded.emit(this.polygon)\n      })\n  }\n\n  public ngOnChanges(changes: { [propertyName: string]: SimpleChange }) {\n    if (changes.points && !changes.points.isFirstChange()) {\n      this.polygon.setPath(toPoints(changes.points.currentValue))\n    }\n    if (changes.options && !changes.options.isFirstChange()) {\n      this.setOptions(changes.options.currentValue)\n    }\n  }\n\n  public ngOnDestroy() {\n    this._service.removeOverlay(this.polygon)\n  }\n\n  private setOptions(options: PolygonOptions): void {\n    if (isNull(options)) {\n      return\n    }\n    if (!isUndefined(options.enableEditing)) {\n      if (options.enableEditing) {\n        this.polygon.enableEditing()\n      } else {\n        this.polygon.disableEditing()\n      }\n    }\n    if (!isUndefined(options.enableMassClear)) {\n      if (options.enableEditing) {\n        this.polygon.enableMassClear()\n      } else {\n        this.polygon.disableMassClear()\n      }\n    }\n    if (!isUndefined(options.strokeColor)) {\n      this.polygon.setStrokeColor(options.strokeColor)\n    }\n    if (!isUndefined(options.fillColor)) {\n      this.polygon.setFillColor(options.fillColor)\n    }\n    if (!isUndefined(options.strokeOpacity)) {\n      this.polygon.setStrokeOpacity(options.strokeOpacity)\n    }\n    if (!isUndefined(options.fillOpacity)) {\n      this.polygon.setFillOpacity(options.fillOpacity)\n    }\n    if (!isUndefined(options.strokeStyle)) {\n      this.polygon.setStrokeStyle(options.strokeStyle)\n    }\n    if (!isUndefined(options.strokeWeight)) {\n      this.polygon.setStrokeWeight(options.strokeWeight)\n    }\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChange\n} from '@angular/core'\n\nimport { nullCheck } from '../helpers/validate'\nimport { MapService } from '../providers/mapService'\nimport { BHeatmap, HeatmapOptions, HeatmapData } from '../types/Heatmap'\nimport { ScriptLoader } from '../providers/scriptLoader'\n\nconst LIB_URL = `https://api.map.baidu.com/library/Heatmap/2.0/src/Heatmap_min.js`\n\n@Directive({\n  selector: 'heatmap'\n})\nexport class HeatmapComponent implements OnInit, OnChanges, OnDestroy {\n  @Input() private dataset: HeatmapData\n  @Input() private options: HeatmapOptions\n\n  @Output() private loaded = new EventEmitter()\n\n  private heatmap: BHeatmap\n\n  constructor(private _service: MapService, private scriptLoader: ScriptLoader) {}\n\n  public ngOnInit() {\n    nullCheck(this.dataset, 'dataset is required for <heatmap>')\n\n    this._service.getNativeMap().then(() => {\n      return this.scriptLoader.load(LIB_URL, false, () => {\n        this._service\n          .addOverlay(() => {\n            return (this.heatmap = new window.BMapLib.HeatmapOverlay(this.options))\n          })\n          .then(() => {\n            this.loaded.emit(this.heatmap)\n            if (this.dataset) {\n              this.heatmap.setDataSet(this.dataset)\n            }\n          })\n      })\n    })\n  }\n\n  public ngOnChanges(changes: { [propertyName: string]: SimpleChange }) {\n    if (changes.dataset && !changes.dataset.isFirstChange()) {\n      this.heatmap.setDataSet(changes.dataset.currentValue)\n    }\n    if (changes.options && !changes.options.isFirstChange()) {\n      this.heatmap.setOptions(changes.options.currentValue)\n    }\n  }\n\n  public ngOnDestroy() {\n    this._service.removeOverlay(this.heatmap)\n  }\n}\n","import { Directive, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'\n\nimport { MapService } from '../providers/mapService'\nimport { BTileLayer, TileLayerOptions, getTilesUrlFunc } from '../types/TileLayer'\nimport { BPixel } from '../types/Pixel'\n\n@Directive({\n  selector: 'tilelayer'\n})\nexport class TileLayerComponent implements OnInit, OnDestroy {\n  @Input()\n  private getTilesUrl: getTilesUrlFunc\n  @Input()\n  private options: TileLayerOptions\n\n  @Output()\n  private loaded = new EventEmitter()\n\n  private tilelayer: BTileLayer\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    const func = this.getTilesUrl\n\n    this._service\n      .addTileLayer(() => {\n        this.tilelayer = new window.BMap.TileLayer(this.options)\n\n        if (this.getTilesUrl) {\n          this.tilelayer.getTilesUrl = function(tileCoord: BPixel, zoom: number) {\n            return func(tileCoord, zoom)\n          }\n        }\n        return this.tilelayer\n      })\n      .then(() => {\n        this.loaded.emit(this.tilelayer)\n      })\n  }\n\n  public ngOnDestroy() {\n    this._service.removeTileLayer(this.tilelayer)\n  }\n}\n","import { Directive, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'\n\nimport { MapService } from '../providers/mapService'\nimport { BTrafficLayer, TrafficLayerOptions } from '../types/TrafficLayer'\n\n@Directive({\n  selector: 'trafficlayer'\n})\nexport class TrafficLayerComponent implements OnInit, OnDestroy {\n  @Input()\n  private options: TrafficLayerOptions\n\n  @Output()\n  private loaded = new EventEmitter()\n\n  private trafficlayer: BTrafficLayer\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    this._service\n      .addTileLayer(() => {\n        this.trafficlayer = new window.BMap.TrafficLayer(this.options)\n        return this.trafficlayer\n      })\n      .then(() => {\n        this.loaded.emit(this.trafficlayer)\n      })\n  }\n\n  public ngOnDestroy() {\n    this._service.removeTileLayer(this.trafficlayer)\n  }\n}\n","import { Directive, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'\n\nimport { MapService } from '../providers/mapService'\nimport { BCanvasLayer, CanvasLayerOptions, BCanvasLayerOptions } from '../types/CanvasLayer'\nimport { isNumber } from '../helpers/object'\nimport { BMapInstance } from '../types/Map'\n\n@Directive({\n  selector: 'canvaslayer'\n})\nexport class CanvasLayerComponent implements OnInit, OnDestroy {\n  @Input()\n  private options: CanvasLayerOptions\n\n  @Output()\n  private loaded = new EventEmitter()\n\n  private canvaslayer: BCanvasLayer\n\n  constructor(private _service: MapService) {}\n\n  public ngOnInit() {\n    this._service\n      .addOverlay((map: BMapInstance) => {\n        this.canvaslayer = new window.BMap.CanvasLayer(this.getOptions(this.options, map))\n        return this.canvaslayer\n      })\n      .then(() => {\n        this.loaded.emit(this.canvaslayer)\n      })\n  }\n\n  public ngOnDestroy() {\n    this._service.removeOverlay(this.canvaslayer)\n  }\n\n  private getOptions(options: CanvasLayerOptions, map: BMapInstance): BCanvasLayerOptions | undefined {\n    if (!options) {\n      return\n    }\n    const opts: BCanvasLayerOptions = {}\n\n    if (isNumber(options.zIndex)) {\n      opts.zIndex = options.zIndex\n    }\n    if (options.paneName) {\n      opts.paneName = options.paneName\n    }\n    if (options.update) {\n      opts.update = function() {\n        return options.update(map, this.canvas)\n      }\n    }\n\n    return opts\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChange\n} from '@angular/core'\n\nimport { nullCheck } from '../helpers/validate'\nimport { isUndefined } from '../helpers/object'\nimport { toMarkerClustererOptions, toPoint, toMarkerOptions, toTextIconStyle } from '../helpers/transformer'\nimport { MapService } from '../providers/mapService'\nimport { MarkerClustererOptions, BMarkerClusterer } from '../types/MarkerClusterer'\nimport { ScriptLoader } from '../providers/scriptLoader'\nimport { BMapInstance } from '../types/Map'\n\nconst LIB_URLS = {\n  key: 'markerClusterer',\n  scripts: [\n    'https://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer_min.js',\n    'https://api.map.baidu.com/library/TextIconOverlay/1.2/src/TextIconOverlay_min.js'\n  ]\n}\n\n@Directive({\n  selector: 'marker-clusterer'\n})\nexport class MarkerClustererComponent implements OnInit, OnChanges, OnDestroy {\n  @Input() private options: MarkerClustererOptions\n\n  @Output() private loaded = new EventEmitter()\n\n  private markerClusterer: BMarkerClusterer\n\n  constructor(private _service: MapService, private scriptLoader: ScriptLoader) {}\n\n  public ngOnInit() {\n    nullCheck(this.options, 'options is required for <marker-clusterer>')\n\n    this._service.getNativeMap().then((map: BMapInstance) => {\n      return this.scriptLoader.load(LIB_URLS, false, () => {\n        this.markerClusterer = new window.BMapLib.MarkerClusterer(map, toMarkerClustererOptions(this.options))\n\n        this.loaded.emit(this.markerClusterer)\n      })\n    })\n  }\n\n  public ngOnChanges(changes: { [propertyName: string]: SimpleChange }) {\n    if (changes.options && !changes.options.isFirstChange()) {\n      this.resetOptions(changes.options.currentValue)\n    }\n  }\n\n  private resetOptions(options: MarkerClustererOptions) {\n    if (options.markers) {\n      this.markerClusterer.clearMarkers()\n      this.markerClusterer.addMarkers(\n        options.markers.map(m => new window.BMap.Marker(toPoint(m.point), toMarkerOptions(m.options)))\n      )\n    }\n    if (!isUndefined(options.girdSize)) {\n      this.markerClusterer.setGridSize(options.girdSize)\n    }\n    if (!isUndefined(options.maxZoom)) {\n      this.markerClusterer.setMaxZoom(options.maxZoom)\n    }\n    if (options.styles) {\n      this.markerClusterer.setStyles(options.styles.filter(s => s).map(s => toTextIconStyle(s)))\n    }\n  }\n\n  public ngOnDestroy() {\n    this.markerClusterer.clearMarkers()\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core'\n\nimport { ControlComponent } from './components/control.component'\nimport { MapComponent } from './components/map.component'\nimport { MarkerComponent } from './components/marker.component'\nimport { PolylineComponent } from './components/polyline.component'\nimport { CircleComponent } from './components/circle.component'\nimport { PolygonComponent } from './components/polygon.component'\nimport { HeatmapComponent } from './components/heatmap.component'\nimport { TileLayerComponent } from './components/tilelayer.component'\nimport { TrafficLayerComponent } from './components/trafficlayer.component'\nimport { CanvasLayerComponent } from './components/canvaslayer.component'\nimport { MarkerClustererComponent } from './components/markerClusterer.component'\nimport { LOADING_STATE, ScriptLoader, ScriptLoaderConfig } from './providers/scriptLoader'\n\nimport { BMap } from './types/BMap'\nimport { BMapLib } from './types/BMapLib'\n\n@NgModule({\n  declarations: [\n    MapComponent,\n    MarkerComponent,\n    ControlComponent,\n    PolylineComponent,\n    CircleComponent,\n    PolygonComponent,\n    HeatmapComponent,\n    TileLayerComponent,\n    TrafficLayerComponent,\n    CanvasLayerComponent,\n    MarkerClustererComponent\n  ],\n  exports: [\n    MapComponent,\n    MarkerComponent,\n    ControlComponent,\n    PolylineComponent,\n    CircleComponent,\n    PolygonComponent,\n    HeatmapComponent,\n    TileLayerComponent,\n    TrafficLayerComponent,\n    CanvasLayerComponent,\n    MarkerClustererComponent\n  ]\n})\nexport class BaiduMapModule {\n  public static forRoot(_config?: ScriptLoaderConfig): ModuleWithProviders {\n    return {\n      ngModule: BaiduMapModule,\n      providers: [{ provide: ScriptLoaderConfig, useValue: _config }, ScriptLoader]\n    }\n  }\n}\n\nexport { BMapInstance, MapOptions, MapTypeEnum } from './types/Map'\nexport { BMapType } from './types/MapType'\nexport { BProjection } from './types/Projection'\nexport { Point } from './types/Point'\nexport { BMarker, Marker, MarkerOptions } from './types/Marker'\nexport { BPolyline, PolylineOptions } from './types/Polyline'\nexport { BCircle, CircleOptions } from './types/Circle'\nexport { BPolygon, PolygonOptions } from './types/Polygon'\nexport { BHeatmap, HeatmapOptions, HeatmapData } from './types/Heatmap'\nexport { BTileLayer, TileLayerOptions, getTilesUrlFunc } from './types/TileLayer'\nexport { BTrafficLayer, TrafficLayerOptions, PredictDate } from './types/TrafficLayer'\nexport { BCanvasLayer, CanvasLayerOptions } from './types/CanvasLayer'\nexport { BMarkerClusterer, MarkerClustererOptions } from './types/MarkerClusterer'\nexport { TextIconStyle } from './types/TextIconOverlay'\nexport {\n  BControl,\n  BNavigationControl,\n  BOverviewMapControl,\n  BScaleControl,\n  BMapTypeControl,\n  BGeolocationControl,\n  BPanoramaControlControl,\n  ControlType,\n  ControlAnchor,\n  GeolocationControlOptions,\n  LengthUnit,\n  NavigationControlOptions,\n  NavigationControlType,\n  OverviewMapControlOptions,\n  ScaleControlOptions,\n  MapTypeControlOptions,\n  MapTypeControlType\n} from './types/Control'\nexport { BInfoWindowConstructor, BInfoWindowOptions, BInfoWindow } from './types/InfoWindow'\nexport { Animation } from './types/Animation'\n\ndeclare global {\n  interface Window {\n    _scriptLoadState: { [url: string]: LOADING_STATE }\n    _loadingCallbacks: { [url: string]: Array<() => void> }\n    BMap: BMap\n    BMapLib: BMapLib\n    baidumapinit: () => void\n    BMAP_PERSPECTIVE_MAP: any\n  }\n}\n","import { BIcon, Icon } from './Icon'\nimport { BSize, Size } from './Size'\n\nexport interface BControlConstructor {\n  new (opts: any): BControl\n}\n\nexport interface BControl {}\n\nexport interface BNavigationControlConstructor extends BControlConstructor {\n  new (opts: BNavigationControlOptions): BNavigationControl\n}\n\nexport interface BOverviewMapControlConstructor extends BControlConstructor {\n  new (opts: BOverviewMapControlOptions): BOverviewMapControl\n}\n\nexport interface BScaleControlConstructor extends BControlConstructor {\n  new (opts: BScaleControlOptions): BScaleControl\n}\n\nexport interface BMapTypeControlConstructor extends BControlConstructor {\n  new (opts: BMapTypeControlOptions): BMapTypeControl\n}\n\nexport interface BGeolocationConstructor extends BControlConstructor {\n  new (opts: BGeolocationControlOptions): BGeolocationControl\n}\n\nexport interface BPanoramaControlConstructor extends BControlConstructor {\n  new (): BPanoramaControlControl\n}\n\nexport interface BNavigationControl extends BControl {\n  getType(): NavigationControlType\n  setType(type: NavigationControlType): void\n}\n\nexport interface BOverviewMapControl extends BControl {\n  changeView(): void\n  setSize(size: BSize): void\n  getSize(): BSize\n}\n\nexport interface BScaleControl extends BControl {\n  getUnit(): LengthUnit\n  setUnit(unit: LengthUnit): void\n}\n\nexport interface BMapTypeControl extends BControl {}\n\nexport interface BGeolocationControl extends BControl {\n  location(): void\n  getAddressComponent(): AddressComponent\n}\n\nexport interface BPanoramaControlControl extends BControl {}\n\nexport interface ControlOptions {\n  anchor?: ControlAnchor\n  offset?: Size\n}\n\nexport interface BControlOptions {\n  anchor?: ControlAnchor\n  offset?: BSize\n}\n\nexport interface NavigationControlOptions extends ControlOptions {\n  type?: NavigationControlType\n  showZoomInfo?: boolean\n  enableGeolocation?: boolean\n}\n\nexport interface BNavigationControlOptions extends BControlOptions {\n  type?: NavigationControlType\n  showZoomInfo?: boolean\n  enableGeolocation?: boolean\n}\n\nexport interface OverviewMapControlOptions extends ControlOptions {\n  size?: Size\n  isOpen?: boolean\n}\n\nexport interface BOverviewMapControlOptions extends BControlOptions {\n  size?: BSize\n  isOpen?: boolean\n}\n\nexport interface ScaleControlOptions extends ControlOptions {}\n\nexport interface BScaleControlOptions extends BControlOptions {}\n\nexport interface MapTypeControlOptions {\n  type?: MapTypeControlType\n}\n\nexport interface BMapTypeControlOptions {\n  type?: MapTypeControlType\n}\n\nexport interface GeolocationControlOptions extends ControlOptions {\n  showAddressBar?: boolean\n  enableAutoLocation?: boolean\n  locationIcon?: Icon\n}\n\nexport interface BGeolocationControlOptions extends BControlOptions {\n  showAddressBar?: boolean\n  enableAutoLocation?: boolean\n  locationIcon?: BIcon\n}\n\nexport enum ControlAnchor {\n  BMAP_ANCHOR_TOP_LEFT = 0,\n  BMAP_ANCHOR_TOP_RIGHT = 1,\n  BMAP_ANCHOR_BOTTOM_LEFT = 2,\n  BMAP_ANCHOR_BOTTOM_RIGHT = 3\n}\n\nexport enum NavigationControlType {\n  BMAP_NAVIGATION_CONTROL_LARGE = 0,\n  BMAP_NAVIGATION_CONTROL_SMALL = 1,\n  BMAP_NAVIGATION_CONTROL_PAN = 2,\n  BMAP_NAVIGATION_CONTROL_ZOOM = 3\n}\n\nexport enum MapTypeControlType {\n  BMAP_MAPTYPE_CONTROL_HORIZONTAL = 0,\n  BMAP_MAPTYPE_CONTROL_DROPDOWN = 1,\n  BMAP_MAPTYPE_CONTROL_MAP = 2\n}\n\nexport enum LengthUnit {\n  BMAP_UNIT_METRIC = 'metric',\n  BMAP_UNIT_IMPERIAL = 'us'\n}\n\nexport interface AddressComponent {\n  streetNumber: string\n  street: string\n  district: string\n  city: string\n  province: string\n}\n\nexport type ControlType = 'navigation' | 'overviewmap' | 'scale' | 'maptype' | 'geolocation' | 'panorama'\n"]}